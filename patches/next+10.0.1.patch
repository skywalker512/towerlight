diff --git a/node_modules/next/dist/build/webpack-config.js b/node_modules/next/dist/build/webpack-config.js
index c954ebe..827b8f6 100644
--- a/node_modules/next/dist/build/webpack-config.js
+++ b/node_modules/next/dist/build/webpack-config.js
@@ -61,7 +61,7 @@ if(!isNextExternal){// Bundled Node.js code is relocated without its node_module
 // This means we need to make sure its request resolves to the same
 // package that'll be available at runtime. If it's not identical,
 // we need to bundle the code (even if it _should_ be external).
-let baseRes;try{baseRes=(0,_resolveRequest.resolveRequest)(request,`${dir}/`);}catch(err){baseRes=null;}// Same as above: if the package, when required from the root,
+let baseRes;try{baseRes=(0,_resolveRequest.resolveRequest)(request,`${dir}/`); }catch(err){baseRes=null;}// Same as above: if the package, when required from the root,
 // would be different from what the real resolution would use, we
 // cannot externalize it.
 if(!baseRes||baseRes!==res&&// if res and baseRes are symlinks they could point to the the same file
@@ -73,7 +73,7 @@ if(res.match(/node_modules[/\\]webpack/)||res.match(/node_modules[/\\]css-loader
 if(isNextExternal||res.match(/node_modules[/\\].*\.js$/)){const externalRequest=isNextExternal?// Generate Next.js external import
 _path.default.posix.join('next','dist',_path.default.relative(// Root of Next.js package:
 _path.default.join(__dirname,'..'),res)// Windows path normalization
-.replace(/\\/g,'/')):request;return callback(undefined,`commonjs ${externalRequest}`);}// Default behavior: bundle the code!
+.replace(/\\/g,'/')):request; if(/^react$/.test(externalRequest)) return callback(undefined, 'commonjs ' + externalRequest); return callback();}// Default behavior: bundle the code!
 callback();}let webpackConfig={externals:!isServer?// make sure importing "next" is handled gracefully for client
 // bundles in case a user imported types and it wasn't removed
 // TODO: should we warn/error for this instead?
